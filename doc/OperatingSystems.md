# 操作系统

### 一 、引论

1. 定义：操作系统是一组控制和管理计算机硬件和软件资源，合理对各类作业进行调度，以便用户使用的程序集合，是用户与计算机的接口。

2. 操作系统
   + UNIX
   + Linux
   + DOS
   + Windows

3. 操作系统的目的
   + 方便性
   + 有效性
   + 可扩充性
   + 开放性

4. 作用
   + 用户与硬件系统的接口
     + 软件接口，给用户提供三种使用方式来使用计算机
       + 命令方式
       + 系统调用方式
       + 图形，窗口方式
   + 计算机四类资源的管理者
     + 处理机管理
     + 存储器管理
     + 设备管理
     + 文件管理
   + 用作扩充机器
     + 裸机：无任何软件的计算机系统
     + 虚拟机：覆盖了软件的机器

5. 操作系统的发展过程
   + 无操作系统的计算机系统：ENIAC
   + 单道批处理系统（50年代）
     + 自动性：无人工干预
     + 顺序性：按进入内存的先后执行
     + 单道性：内存中只保持一道作业
   + 多道批处理系统（60年代）
     + 内存中同时存放多个相互独立的程序
     + 多道技术是共享的基础
     + 特点：
       + 多道性：内存中右多道程序，可并发执行
       + 无序性：完成时间与进入内存先后无关，提高了系统资源的利用率
       + 调度性：作业从提交到完成经过两次调度
         + 作业调度：外存------》内存
         + 进度调度：分配处理机
   + 分时系统（60年代）
     + 定义：一台主机连接了多个终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源
     + 产生动力
       + 人-机交互（边运行边调试）
       + 共享主机（设备昂贵）
       + 便于用户上机（在终端上输入/控制）
     + 特征：
       + 多路性：即同时性，在宏观上同时，微观上轮流，在同一时间范围内为多个用户服务
       + 独立性：每个用户感觉上独占主机
       + 及时性：较短时间响应（2-3秒）
       + 交互性：

   + 实时系统（60年代）
     + 实时：及时响应外部事件请求
     + 应用需求：
       + 实时控制：工业生产，武器控制，飞机自动驾驶等
       + 实时信息处理：订票系统

6. 操作系统的特特征

   - 并发性
     - 并行性：多个事件在同一时刻发生，真正的同时发生
     - 并发性：多个事件在同一时间间隔内发生
     - 单处理机系统：宏观并发，微观串行
     - 多处理机系统：可能有并行
   - 共享性
     - 互斥共享方式：对临界资源的访问
       - 临界资源：一次只允许一个进程访问：打印机，栈，变量等
     - 同时访问方式
       - 多个进程同时访问的资源：磁盘
   - 虚拟性
     - 通过某种技术把一个物理实体变为若干逻辑上的对应物
     - 虚拟处理机，虚拟内存
   - 异步性
     - 概念：进程以不可预知的速度向前推进

   

------



### 二、进程管理

#### 1.进程概念

+ 进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位，一个进程就是一个正在执行程序的实例

+ 程序在并发环境中的执行过程
+ 特征
  + 结构特征
    + 进程控制块：PCB，相当于一个进程的头脑，动态特征的集中反映
    + 程序段：描述要完成的功能
    + 数据段：操作对象和工作区
  + 动态性
    + 进程有创建而产生，由调度而执行，由撤销而消亡
  + 并发性：多个进程同在内存中，且能在一段时间内同时运行
  + 独立性：进程时一个能独立运行，独立分配资源，独立接受调度的基本单位
  + 异步性：进程按各自独立的，不可预知的速度向前推进

#### 2.PCB

- PCB特征
  - PCB是OS中最重要的记录型结构
  - OS用PCB对并发进程进行管理和控制
  - PCB是进程存在的唯一标志
  - PCB常驻内存
  - OS专门开辟PCB区将所有的PCB组成若干个链表或队列
- PCB中的信息
  - 进程标识符
    - 内部标识符：进程唯一的数字编号，给OS使用
    - 外部标识符：由字母，数字组成，给用户使用
  - 处理机状态
    - 处理机中主要的寄存器
      - 通用寄存器：8-32，暂存信息用
      - 指令计数器：要访问的下一条指令的地址
      - 程序状态字PSW：条件码，执行方式，中断屏蔽标志
      - 用户栈指针：用户进程拥有的系统栈，存放过程和系统调用参数及调用地址
  - 进程调度信息
    - 进程状态
    - 进程优先级
      - 用一个整数来表示
      - 整数数值越大，优先级越高；优先级越高，就越可能占有处理机
    - 与调度算法有关信息
    - 事件，如阻塞原因
  - 进程控制信息
    - 程序和数据地址
    - 进程同步和通信机制
    - 资源清单：除CPU之外的所需资源与已经分配资源清单
    - 链接指针：本进程PCB所在队列的下一个地址
- PCB的组织方式
  - 链接方式
    - 将统一状态的进程划分为一组，创建一个指针指向这个组的第一个进程，根据PCB中存储的链接指针进行
  - 索引方式

#### 3.进程和程序

1. 程序顺序执行的特征
   - 顺序性：处理机的操作严格按照程序所规定的顺序执行
   - 封闭性：程序在封闭的环境下执行，结果不受外界因素的影响
   - 可再见性：只要环境和初始条件享用，程序重复执行时总得到相同结果
2. 并发程序执行的特征
   + 间断性：共享，合作，制约导致
   + 失去封闭性：资源状态由多程序改变
   + 不可再见性：相同和环境和初始条件重复执行结果不同
3. 进程和程序的关系
   + 进程是一个动态概念，程序是一个静态概念
   + 进程具有并行特征，程序具有顺序性
   + 进程是竞争资源的基本单位，程序没有
   + 一个程序对应多个进程，一个进程为多个程序服务

#### 4.进程的状态

1. 进程的三种基本状态
   + 就绪状态
     + 进程已经分配了除处理机之外的所有必要资源，只要再获得处理机就能够执行的状态
     + 这样的进程可能有多个，通常排成一个队列
   + 执行状态
     + 已经获得CPU，正在运行
     + 在单CPU系统只有一个进程处于执行状态。多CPU系统则有多个处于执行状态
   + 阻塞状态
     + 正在执行的进程由于发生某事件而暂时无法继续执行，放弃处理机而进入的状态，又称等待状态
     + 引起阻塞的事件：请求I/O，申请缓存
2. 挂起状态
   + 引入原因
     + 终端用户请求
     + 父进程请求
     + 负荷调节需要
     + 操作系统需要

#### 5.进程的管理

+ 进程管理章最基本功能就是进程控制

+ 进程控制任务：

  + 进程的创建，终止，进程状态的转变等

+ 进程控制一般由OS内核实现

+ 引起创建进程的事件

  + 由系统内核创建
    + 用户登录
    + 作业调度
      + 将外存中的多个作业选择一个或多个调到内存中
    + 提供服务
  + 自己创建
    + 应用请求

+ 进程的创建

  + 申请空白PCB
  + 为新进程分配资源
  + 初始化进程控制块
  + 将新进程插入就绪队列
  + PCB的初始化
    + 初始化标识信息
    + 初始化处理机状态信息
    + 初始化处理机控制信息

+ 进程终止

  + 死因
    + 正常结束
    + 异常结束
      + 越界错误
      + 保护错：读写权限不够
      + 非法指令：
      + 特权指令错：
      + 运行超时：
      + 等待超时：
      + 算术运算错
      + I/O故障
    + 外界干预
      + 操作员或OS干预
      + 被父进程终止：父进程拥有比子进程更大的权力，父进程随时可以终止子进程
      + 父进程终止：父进程终止了，子进程也将随之终止
  + 过程
    + 从PCB集合中检索出该进程的PCB，从中读出该进程的状态
    + 若处于执行，终止该进程的执行，并置调度标志为真，重新调度
    + 若有子进程，将所有子孙进程终止
    + 将进程全部资源归还其父进程或系统
    + 将其PCB从所在队列（l链表）中移除

+ 进程状态转换

  + 引起阻塞和唤醒的事件
    + 请求系统服务
    + 启动某种操作
    + 新数据尚未到
    + 无新工作可做
  + 进程阻塞过程（BLOCK）
  + 进程唤醒过程（WakeUp）
    + 从等待队列中摘下给唤醒的进程
    + 置该进程的状态转为就绪态，并放入就绪队列
    + 转进程调度或返回
    + 注意：如果在某进程中调用了阻塞原语，则必须在与之相合作的另一个进程中或其他相关的进程中，安排唤醒原语，以便能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久处于阻塞状态，从而再无机会继续执行
  + 进程的挂起（Suspend）：内存  -----》外存
    + 检查被挂起进程的状态：
      + 若处于活动就绪状态，改为静止就绪；
      + 若处于活动阻塞状态，则改为静止阻塞；
      + 若正在执行，则转向调度程序重新调度

+ 进程的制约关系

  - 间接制约------互斥

    - 进程间由于共享某种资源，而形成的相互制约
    - 互斥：并发执行的多个进程由于竞争统一资源而产生的相互排斥的关系

  - 直接制约-------同步

    - 进程间由于合作而形成的相互制约
    - 同步：进程间共同完成一项任务时直接发生相互作用的关系
    - 同步进程间具有合作关系，在执行时间上必须按一定的顺序协调进行

  - 临界资源

    - 一次仅允许一个进程使用的共享资源：如打印机，磁带机，表格等

  - 临界区

    - 在每个进程中访问临界资源的那段程序
      - 进程必须互斥进入临界区
    - 访问临界区
      - 进去区：检查临界资源是否能访问
      - 临界区：
      - 推出区：将临界区标志设为未访问
      - 剩余区
    - 同步机制遵循的原则
      - 空闲让进
      - 忙则等待
      - 有限等待
      - 让权等待：正在执行的进程，如果判断不能使用临界资源，就必须放弃CPU资源

  - 信号量

    - 整信号量

      - Wait(s)

      ```c
      while S <= 0 do no-op
      	  S:=S-1;
      ```

      - Signal(s)

      ```c
      S:=S+1;
      ```

      - wait（s）和signa（s）是原子操作，执行过程中不允许插入任何其他操作
      - 只要信号量S<=0就不断测试，不满足让权等待，因为当判断发现自己不能使用临界资源的时候，因此自身的原子性，导致仍然占用CPU进行while判断，浪费CPU资源

    - 记录型信号量

      - 记录型结构，包含两个数据项

      ```
      type semaphore = record
      			value : integer;
      			L:list of process;	//进程的PCB链表
      			end
      ```

      - 结构

        - S.value为资源信号量其初值：某类资源的数目

          - S.value>=0时：代表系统当中可用资源的数目
          - S.value<0时：它的绝对值代表等待使用资源的进程个数
          - S.value初值为1时：只允许一个进程访问临界资源，是互斥信号量

        - wait操作：申请一个单位资源

          ```c
          Procedure wait(s)	//
          Var S:semaphore;
          begin
          	S.value:=S.value-1;
          	if S.value<0 then block(s,L)	//s指资源，进入阻塞队列
          end
          
          ```

        - signal操作：释放一个资源

          ```c
          Procedure signal(s)
          Var s:semaphore;
          begin
          	S.value:=S.value+1;
          	If S.value<=0 then wakeup(s,L)	//唤醒一个等待的进程，进入就绪队列
          end
          ```

    - AND型信号量

      - 基本思想：将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放

+ 进程通信

  + 概念：进程通信就是进程之间真的信息交换

  + 交换的信息量：

    + 一个状态或数字
    + 上千个字节

  + 分类

    + 低级通信：进程的互斥和同步
    + 高级通信：用户可直接利用操作系统提供的一组通信命令，
      + 高效地传输大量数据的通信方式
      + 对用户通明（用户不需要考虑系统的具体操作，仍可完成操作）。

  + 高级通信

    + 分类

      + 共享存储器系统
        + 共享数据结构：如缓冲池数据结构，这属于低级通信方式
        + 共享存储区：在存储区中划出一块共享存储区
      + 消息传递系统
        + 信息交换的单位是消息或报文
        + 直接通信方式
          + 发送进程直接把消息发送给目标进程
          + 发送进程和接收进程都以显式方式分别提供给对方标识符
          + 系统提供两条通信原语
            + Send（Receiver，message）
            + Receive（Send，message）
        + 间接通信方式
          + 进程之间的通信需要通过某种中间实体
          + 这种中间实体成为信箱
            + 私用信箱
              + 用户进程建立，作为该进程的一部分
              + 拥有者有权读消息，其他用户只能发送
              + 采用单向通信链路
              + 进程结束时信箱也消失
            + 公用信箱
              + 有OS创建
              + 提供给系统中的所有核准进程使用
              + 进程既发送也可取出
              + 采用双向通向链路的信箱来实现
            + 共享信箱
              + 由某个进程创建，创建时提供共享进程的名字
              + 信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息
          + 消息在信箱中可以安全地保存，只允许核准的目标用户随时读取，故可实现非实时通信
      + 管道通信
        + 建立在文件系统的基础上，利用共享文件来连接两个相互通信的进程，此共享文件称为管道（Pipe）
        + 管道时指用于连接一个读进程和写进程，以实现他们之间通信的共享文件
        + 文件存放在外存，节约内存资源
        + 管道通信必需的协调能力
          + 互斥
          + 同步

------

### 三、线程

#### 1.基本概念

+ 引入线程的目的
  + 进程是可拥有资源的基本单位，可独立调度和分配的基本单位。
  + 创建，撤销和切换中，系统必须付出较大的时空开销。故进程，其数目不宜过多，进程切换的频率也不宜过高。
  + 进程不应同时作为拥有资源的单位，可独立调度和分配的基本单位。
+ 线程的属性
  + 轻型实体：线程中的实体基本上不拥有系统资源
  + 独立调度和分配的基本单位，线程的切换速度快，开销小
  + 一个进程内部包含多个线程，多个线程可以并发；一个线程也可以同时与其他进程的线程并发执行
  + 共享进程资源

------

### 四、处理机调度

#### 1.高级调度

+ 又称作业调度，长程调度，接纳调度
+ 作用：
  + 把外存上处于后备队列中的作业调度内存，
  + 并为他们创建进程，分配资源，
  + 排在就绪队列上，准备执行
+ 使用地方：分时系统和实时系统通常不需要作业调度

#### 2.低级调度

- 也称为进程调度，短程调度
- 作用：
  - 决定就绪队列中哪个进程应获得处理机（选择）
  - 然后由分配程序执行把处理机分配给该进程（分配）
- 使用地方：在OS中都必须配置

- 调度方式
  - 非抢占方式
    - 一旦把处理机分配给某个进程，便让该进程一直执行，直到该进程完成或阻塞时，才再把处理机分配给其他进程
    - 调度因素：
      - 进程执行完毕，或因发生某事件不能继续执行
      - 执行中的进程提出I/O请求而暂停执行
      - 在进程通信或同步过程中执行了某种原语操作
  - 抢占方式
    - 允许暂停某个正在执行的进程，将已经分配给进程的处理机分配给另一个进程
    - 抢占原则：
      - 优先权原则：优先权高的进程抢占处理机
      - 短作业优先原则：短作业抢占当前较长作业的处理机
    - 时间片原则

#### 3.中级调度

+ 又称中程调度，是挂机和激活得以实现的方式

+ 目的：提高内存的利用率和系统的吞吐率
+ 作用：使暂时不能运行的进程从内存调至外存，进入就绪驻外存状态或挂机状态。把外存上又具有运行条件的就绪进程，重新调入内存，并修改为就绪状态，挂在就绪队列。

#### 4.调度队列

+ 三种模型
  + 仅有进程调度的调度队列模型
    + 通常，把就绪进程组织称FIFO队列，每当创建一个新进程时排在就绪队列的末尾，按时间片轮转方式运行。
    + 使用此模型，进程在执行时，出现的三种情况
      + 任务在时间片内完成，进程便在释放处理机后进入完成状态；
      + 任务在时间片内未完成，OS便将该任务再放入就绪队列的末尾；
      + 如果进程处于阻塞状态，被OS放入阻塞队列末尾；
  + 又高级调度和低级调度的调度队列模型
    + 与前一模型的差别
      + 就绪队列形式：批处理系统中最常用的是优先权队列，也可采用无序链表方式（优先权越大越靠前）
      + 设置多个阻塞队列，根据阻塞原因创建不同的阻塞队列
  + 有三级调度的调度队列模型
    + 调出时，可使进程状态由内存就绪态转变为外存就绪，由内存阻塞转变为外存阻塞
    + 在中级调度使外存就绪转变为内存就绪

#### 5.选择调度方式和调度算法的准则

+ 面向用户
  + 周转时间短
    + 从作业被提交给系统开始，到作业完成为止这段时间间隔，包括四部分时间：
      + 在外存后备队列上等待调度的时间：高级调度
      + 进程在就绪队列上等待调度的时间：低级调度
      + 进程在CPU上执行的时间
      + 进程等待I/O操作完成的时间
  + 响应时间快
    + 用户通过键盘提交一个请求开始直至系统首次产生响应为止的时间间隔
  + 截至时间的保证
    + 某任务必须开始执行的最迟时间，或必须完成的最迟时间
  + 优先权准则
+ 面向系统
  + 系统吞吐量高
    + 单位时间内系统完成的作业数
  + 处理机利用率好
  + 资源的平衡利用

#### 6.调度算法 

1. 概念
   + 调度算法是指：根据系统的资源分配策略所规定的资源分配算法
2. 先来先服务调度算法：FCFS（First Come First Serve）
   + 调度原理
     + 作业调度中每次从后备作业队列中，选择一个或多个最先进入该队列的作业调入内存，为他们分配资源，创建进程，然后放入就绪队列（高级调度）
     + 进程调度时每次从就绪队列中，选择一个最先进入该队列的进程进行分配处理机使之运行。直到完成或阻塞后，才放弃处理机（低级调度）
   + 特点：
     + 是一种最简单的调度算法，既可以用于作业调度，也可用于进程调度
     + 有利于长作业（进程），而不利于短作业（进程）
     + 有利于CPU繁忙型作业（计算型的，不需要进行I/O），不利于
3. 短作业（进程）运行法：SJF（SRF）
   + 原理
     + 从后备队列中选择一个或若干个估计运行时间最短的作业调入到内存运行
   + 特点
     + 有利于短作业，不利于长作业。如果有一长作业进入系统后备队列，由于总是优先调度短作业将导致长作业长期不被执行
     + 完全未考虑到作业的紧迫程度，不能保证紧迫作业会被及时执行
     + 作业的长短根据用户自己确定，有可能出现估计失准
4. 高优先权优先调度算法
   + 优先权调度算法的类型
     + 非抢占式优选权算法
       + 用于批处理系统和某些对实时性要求不高的实时系统
     + 抢占式优先权算法
       + 常用于实时系统
   + 优选权的类型
     + 静态优先权
       + 概念
         + 在创建进程时确定
         + 在进程整个运行期间保持不变
         + 用某一范围内的一个整数来表示，大多数OS，值越大，优先权越高
       + 确定优先权的依据
         + 进程类型：系统进程高于用户进程
         + 进程对资源的要求：要求少的进程应赋予教高优先权
         + 用户要求
       + 优缺点
         + 简单，系统开销小
         + 不精确，仅在要求不高的系统中使用
     + 动态优先权
   + 高响应比优先调度算法
     + 概念
       + 引入动态优先权，并使作业优先级随着等待时间的增加而以速率a提高
     + 优先权的变化规律为：
       + 响应比（优先权） = （等待时间 + 要求服务时间）/ 要求服务时间
     + 优缺点
       + 兼顾长短作业
       + 增加了系统的开销
   + 时间片轮转法
     + 分时系统多采用时间片轮转法
     + 原理
       + 把就绪进程组织成FIFO队列
       + 把CPU分配给队首进程
       + 规定它执行一个时间片
       + 时间片完成时排在就绪队列的末尾，重新把处理机分配给就绪队列中的新的队首进程，也执行一个时间片
   + 多级反馈队列调度算法
     + 为多个就绪队列赋不同的优先级
     + 原理
       + 第一个队列的优先级最高，其余队列逐个降低
       + 各队列中进程执行时间片的也不同，优先权愈高的队列中时间片愈小
5. 实时调度
   + 实时调度基本条件
     + 提供必要的信息
       + 就绪时间
       + 开始截至时间和完成截至时间
         + 开始截至时间：提出任务到系统开始执行的时间间隔
         + 完成截至时间：开始执行到完成的时间间隔
       + 处理时间
       + 资源要求
     + 系统处理能力强
     + 采用抢占式调度机制
     + 具有快速切换机制
   + 分类
     + 按任务性质
       + 硬实时调度算法
       + 软实时调度算法
     + 按调度方式
       + 非抢占式调度算法
         + 非抢占式轮转调度算法
         + 非抢占式优先调度算法
       + 抢占式算法
     + 按调度时间
       + 静态调度算法
       + 动态调度算法
6. EDF算法
   + 根据任务的开始截至时间确定优先级，截至时间越早优先级越高
   + 系统中保持一个实时任务优先级就绪队列，调度程序选择对首任务分配处理机
   + 可采取抢占式也可非抢占式调度
7. LLF算法
   + 根据任务的紧急程度确定优先级，紧急程度越高优先级越高
   + 可采取抢占式也可非抢占式调度
8. 多处理器系统（MPS）
   + 提高系统性能的主要途径有两条
     + 提高元器件的运行速度，特别是处理器芯片的速度
     + 改进计算机系统的体系结构，特别是在系统中引入多个处理器或多台计算机
   + 多处理系统类型
     + 根据耦合性
       + 紧密耦合MPS：通过高速总线或高速交叉开关实现多个处理器互连
         + 它们共享主存和I/O设备，并要求将主存划分为若干个能独立访问的存储器模块，以便多个处理器能同时对主存进行访问
       + 松弛耦合MPS：通过通道或通信线路实现多台计算机之间互连
     + 根据系统中中央处理器的相同与否
       + 对称MPS
         + 系统中处理器单元在功能和结构上都相同
       + 非堆成MPS
         + 只有一个主处理器，其余是从处理器
   + MPS进程分配方式
   + MPS进程（线程）调度方式 
     + 自调度方式
       + 机制：直接由单处理机环境下的调度方式演变来的，
         + 单处理机环境下的FCFS，FPF和抢占式FPF调度算法都可用
         + 整个系统只设置一个就绪队列，供多个处理器共享，
       + 优点：
         + 容易将单处理机环境下的调度机制移植到多处理机系统中
         + 利用率高：共享一个就绪队列，只要队列中有进程就可以被处理机及时调度
       + 缺点
         + 一个就绪队列，供多个处理机共享，这些处理器必须互斥地访问该队列。处理器数目在数十个乃至数百个时，会产生严重瓶颈问题，即当就绪队列中有很多就绪进程时，而访问就绪队列时互斥的，一次只允许一个处理器访问，其他处理器只能处于等待；
         + 低效性
     + 成组调度方式
       + 将一个进程中的一组线程，分配一组处理器上去执行
       + 可用两种方式为应用程序分配处理器时间
         + 面向所有应用程序平均分配处理器时间
         + 面向所有线程平均分配处理器时间
       + 优点：减少线程切换，优于自调度
     + 专用处理机调度方式
       + 在一个程序执行期间，专门为该应用程序分配一组处理器，每一个线程一个处理器，供应用程序直至完成收回处理器
       + 缺点：造成单个处理机的浪费

#### 7.死锁

1. 概念
   + 各个并发进程彼此等待对方拥有的资源，且在得到对方资源前不释放自己的资源而造成的一种僵局
   + 相对方向的两只羊过独木桥
2. 引起的原因
   + 竞争资源：资源数目不能满足进程要求时
   + 进程间推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也同样会造成死锁
3. 资源的分类
   + 可剥夺性资源：指某进程在获得这类资源后，该资源可以被其他进程或系统剥夺。如：CPU，内存
   + 不可剥夺性资源：不能强行收回，只能在进程用完后自行释放。如：磁带机，打印机
4. 竞争非剥夺行资源造成的死锁
   + 非可剥夺性资源数量不够就可能造成死锁
5. 竞争临时性资源
   + 临时性资源：由一个进程产生由另一个进程使用短暂时间后便无用的资源，如：进程产生的消息 
6. 产生死锁的必要条件
   + 互斥条件
     + 进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占有
   + 请求和保持条件
     + 进程已经保持至少一个资源，但又提出新的资源请求，而该资源又已经被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放（吃着碗里的想这锅里的）
   + 不剥夺条件
   + 环路等待条件
     + 在发生死锁时，必然存在一个进程-资源的环性链 
7. 处理死锁的基本方法
   + 预防死锁
     + 设置某些限制条件，破坏四个必要条件中的一个或多个
       + 互斥条件：不可以打破
       + 请求和保持条件：可以
         + 实现：
           + 系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需地全部资源
         + 缺点缺点：资源被严重浪费，恶化了系统地利用率；
       + 不剥夺条件：可以
         + 实现：
           + 一个进程保持了某些资源，再提出新的资源请求而不能立即得到满足时，必须暂时释放它已经保持了地所有该类资源，待以后需要时再重新申请。
         + 缺点：实现复杂
       + 环路等待条件：可以
         + 实现：
         + 缺点：序号必须相对稳定，限制了新设备类型怎加，限制了用户编程
     + 
   + 避免死锁
     + 在资源动态分配过程中，用某种方法去防止系统进入不安全状态
   + 检测死锁
     + 允许发生死锁
     + 检查发生死锁的原因
     + 进行解除
   + 解除死锁
     + 与检测死锁相匹配
     + 常用办法：撤销或挂起一些进程
8. 银行加算法避免死锁 
   + 死锁的解除
     + 剥夺资源：从其他进程剥夺足够的资源给死锁进程
     + 撤销进程
       + 全部撤销
       + 逐步撤销

------

### 五、存储器管理

1. 存储器管理的功能

   + 内存分配：为每个进程分配一定的内存空间
   + 地址映射：把程序中所用的相对地址转换为物理地址
   + 内存保护：检查地址的合法性，防止越界访问
   + 内存扩充：解决“求大于供”的问题，采用虚拟存储奇数

2. 程序的装入和链接

   从用户源程序进入系统到程序在机器上执行，所经历的主要处理阶段有：

   + 编译阶段：将用户源代码编译成若干各目标模块
   + 链接阶段：将一组目标模块及它们需要的库函数链接在一起，形成一个完整的装入模块
   + 装入阶段：将装入模块装入内存
   + 运行阶段

3. 内存空间

   由一系列存储单元所限定的地址范围

   + 物理空间
   + 逻辑地址空间：由程序中逻辑地址组成的地址范围

4. 地址

   + 相对地址：也叫逻辑地址，用户编译程序经编译后的每个目标模块都以0为基地址顺序编址
   + 绝对地址：也叫物理地址，内存中各物理存储单元的地址是从统一的基地址顺序编址

5. 程序的装入

   + 装入方式
     + 绝对装入方式
       + 逻辑地址与实际地址相同
       + 要求程序员熟悉内存的使用情况
       + 通常在程序中采用符号地址
     + 可重定位装入方式
       + 静态装入方式
       + 目标模块从0开始编址，其它地址相对于起始地址计算
       + 重定位：装入时对目标程序中指令和数据的修改过程：逻辑地址转为物理地址的过程
     + 动态运行时装入方式
       + 程序在执行时将相对地址转换位绝对地址

6. 程序的链接

   + 静态链接：执行前将目标模块和他们的库函数，链接成一个完整的装配模块
   + 运行时动态链接：将某些目标模块的链接，推迟到执行时才进行。

7. 内存的分配方式

   + 连续分配方式：为一个用户程序分配一个连续的内存空间
     + 单一连续分配
       + 内存分系统区和用户区，系统区供OS使用
       + 在内存中仅驻留一道程序，整个用户区为一用户使用
       + 不能实现共享
     + 固定分区分配
       + 将内存分为几个固定大小区域，每个区域装入一道用户程序
       + 分类：
         + 分区大小相等：缺乏灵活性，划分多大合适？划分的小，大作业找不到内存块；划分的大，造成内存浪费；
         + 分区大小不等：将分区按大小进行分配，建立分区使用表，表中包含分区的起始地址，大小，状态（是不是已被分配）
     + 动态分区分配
       + 数据结构
         + 空闲分区表：每个分区占一个表目，包含分区序号，分区始址，状态
         + 空闲分区链：在每一个分区的起始部分设置用于控制分区的信息，向前指针；在分区尾部设置一个向后的指针，形成双向链表
       + 分配算法
         + 目的：从空闲区中找出合适的空闲区给进程
         + 首次适应算法FF
           + 空闲分区链以地址递增的次序链接
           + 分配：
             + 从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止
             + 再按作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留再空闲链表中。
             + 若从链首到链尾都不能找到一个能满足要求的分区，则失败返回
           + 缺点：
             + 内存的分布不均匀，低地址分配多
         + 循环首次适应算法
           + 每次从上次找到的下一个分区开始查找，直到找到一个能满足要求的分区；
           + 缺点：是内存缺乏大的空闲分区
         + 最佳适应算法
           + 将所有的空闲分区按其容量以大到小的顺序形成以空闲分区链，第一次找到的空闲区必然是最佳的。
       + 分配与回收操作
         + 分配内存
         + 回收内存操作
     + 动态重定位分区分配
       + 碎片：内存中不能利用的小分区称为“零头”或“碎片”
       + 拼接：也叫“紧凑”，分散的小分区拼接成一个大分区
       + 原理：地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位
       + 算法
     + 对换
       + 分类
         + 整体对换：以整个进程为单位，又称进程对换
         + 部分对换
           + 页面对换
           + 分段对换
       + 外存
         + 文件区
         + 对换区
       + 进程换出过程
         + 选择处于阻塞状态且，优先级最低的进程作为换出进程
         + 然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上
         + 若在传送过程中国未出现错误，便可回收该进程所占用的内存空间，并修改该进程PCB
       + 进程换入过程
         + 系统定时查看所有进程的状态
         + 找出外存“就绪”状态但已换出的进程
         + 将起这个换出时间最久的进程作为换入进程，将之换入
         + 直至已无可换入进程
   + 离散分配方式
     + 基本思想：将一个进程分散的装入不相邻的分区中
     + 分页存储管理方式
       + 什么是页：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页编号，从0开始
       + 什么是块：把内存空间分成与页面相同带线啊哦的若干个存储块，称为块或页框，也加以编号
       + 以块为单位将进程中的若干个页分别装入到多个可以不相邻的物理块中
       + 基本分页存储管理方式
         - 不具备页面对换功能，不支持虚拟存储器功能
       + 页内碎片：由于进程的最后一页经常不满一块而形成不可利用的碎片，称为“页内碎片”
       + 页表：页面系统为了能在内存块中找到每个页面对应的物理块而为进程建立的一张页面映像表，简称页表
         + 作用：实现从页号到物理块号的映射
         + 表项中设有存取控制地段
       + 地址变换机构：
         + 基本任务：实现从逻辑地址到物理地址的转换。实际上是将逻辑地址中的页号，转换为内存中的物理块号
         + 地址变换任务主要是借助页表来完成的
         + 页表由一组专门的寄存器来实现的，一个页表项用一个寄存器
         + 系统只是页表寄存器PTR，存放页表在内存的始值和页表的长度
         + 进程为执行时，页表的始值和页表长度存放在本进程PCB中，当调度到进程时装入页表寄存器中。
       + 为了提高地址变换速度
         + 增设一个具有并行查询能力的高速缓冲寄存器，称为“快表”或“联想存储器”，用于存放当前访问的页表项
         + 过程
           + CPU给出有效地址，由地址变换机构自动将页号p送入高速缓冲存储器，并将此页号与高速缓存中的当前所有页号进行比较
           + 若有于此相匹配的页号，则表示所要访问的页表在快表中
             + 于是，可直接读出该页对应的物理块号，并送物理地址寄存器中
           + 若在快表中没有找到对应的页表项，还须再访问内存中的页表，找到后，把从页表中读出物理块号送地址寄存器；同时，还将此页表项存入到快表中的一个寄存器单元
             + 如果快表已满，则OS必须找到一个老的且已被认为不再需要的页表项将它换出
     + 分段存储管理方式
       + 引入
         + 方便编程
         + 信息共享
         + 信息保护
         + 动态增长
         + 动态链接
       + 分段
         + 作业的地址空间被划分为若干个段，每个段定义一组逻辑信息
         + 每个段从0开始编址。采用一段连续的地址空间。段内是连续的，但是段和段是分散的；
         + 段的长度由相应的逻辑信息组长度决定，因此，长度不等
         + 整个作业的地址空间分为多个段，是二维的
       + 逻辑地址结构
         + 段号
         + 段内地址
       + 段表：系统为每一个进程建立一张段映射表，简称段表。用于实现从逻辑段到物理内存的映射
       + 基本分段存储管理方式
   + 分页和分段区别
     + 页的大小固定且系统决定，段的长度不固定，决定于用户所编写的程序
     + 分页作业地址空间是一维的，分段的作业地址空间是二维的
   + 可重入代码
     + 又称纯代码：一种允许多个进程同时访问但不允许任何进程对它进行修改的代码

8. s

ss





### 六、

s

